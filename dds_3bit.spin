' 
' High Speed RF Direct Digital Synthesizer for Propeller 
' 
' 
' 3 bit output at 128MSPS, when using 80MHz clkfreq 
' Uses the standard Propeller composite video dac circuit. 
' 3 cogs required. 
' 
' This code is able to achieve such speed by pre-calculating groups 
' of 32 samples. 
' 
' Initial calculations suggest that frequencies deviating less than 
' 7700 Hz will use identical tables. In practice it should still 
' work well at several times this as the error will be only a few 
' degrees at the end of the group. Applications such as local 
' oscillators, NBFM, and FSK should work well. 
' 
' This code is NOT suitable for wideband sweeping. 
' 
' 
' Usage:
' dds.start(12)  ' For composite video dac on pins 12:14
'                ' Each bit is generated by a separate cog
'                ' so they can span multiple Vgroups. 
' 
' dds.tune( 10_450_000 )      ' Set the frequency to 10.45 MHz. 
'                             ' Output will mute while 
'                             ' tables are recalculated
'                             ' and PLLs are resynchronized. 
' 
' dds.modulate( 10_450_100 )  ' For small frequency changes 
'                             ' without muting output, continuous phase. 
'                             ' Caller is responsible for ensuring 
'                             ' that the deviation is acceptable.
'                             ' Should call tune() first. 
' 
' 
' The tuning word is reloaded every 10 hub intervals, 
' for an update rate of 500kHz. 
' It should be possible to transmit FM stereo with this code. 
' Keep in mind that you'll need to program an image frequency 
' as the FM band exceeds the Nyquist frequency for this code. 
' 
' 
' 
' Thank you Kuroneko for the information about synchronizing multiple video generators.
' http://forums.parallax.com/discussion/126874/fyi-waitvid-setup-timing-co-updated-20111119
' 
' 
' 
' 
' Copyright (C) 2018 SaucySoliton
' 
' 

{{

TERMS OF USE: MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}


'CON
'  _clkmode = xtal1 + pll16x
'  _XinFREQ = 5_000_000



  
VAR
  long parameter
  long dds_tune
  long dds_sync_time
  long dds_clock_freq
  long this_pin


PUB start(basepin)    'basepin is LSB,   MSB is basepin+2 

  ddsp_tune := @dds_tune            ' configure memory address for dds tuning frequency
  ddsp_time := @dds_sync_time       ' and sync time
  
  dds_sync_time := cnt + 8_000_000  ' This initial value should be meaningless


  dds_clock_freq := (clkfreq*8)/5   ' Calculate once since we don't expect 
                                    ' sysclock to change.
                    
  dds_tune :=  0                    ' 0 means wait for new frequency
                              

  ddsp_phd    := 32 ' Post-hub delay
                    ' It's basically a magic number more easily 
                    ' found by trial and error.

                    ' Tuning procedure:
                    ' Replace   "mov phsa,phsaval" with "nop"
                    ' Adjust magic number phd
                    ' Restore  "mov phsa,phsaval"
                    ' Adjust magic number phsaval factor

  this_pin    :=  basepin+2    
  txp_pin     := 1<<(this_pin)
  ddsp_vgrp   := this_pin/8
  ddsp_shift  := 7
  cognew(@srccog, @parameter)
  waitcnt( 9_000 + cnt )
  
  
  this_pin    :=  basepin+1    
  txp_pin     := 1<<(this_pin)
  ddsp_vgrp   := this_pin/8
  ddsp_shift  := 6
  ddsp_phd    := ddsp_phd-2     ' each cog is 2 cycles later
  cognew(@srccog, @parameter)
  waitcnt( 9_000 + cnt )
  
  
  this_pin    :=  basepin+0    
  txp_pin     := 1<<(this_pin)
  ddsp_vgrp   := this_pin/8
  ddsp_shift  := 5
  ddsp_phd    := ddsp_phd-2  
  cognew(@srccog, @parameter)
  waitcnt( 9_000 + cnt )
  
     
      
PUB ratio( num, denom) : r
  ' compute the 32-bit fixed-point representation of num / denom (so num must be =< denom)
  repeat 32                      
    num <<= 1
    r <<= 1
    if num => denom    '  
      num -= denom
      r++

PUB modulate( freq ) 
  dds_tune :=  ratio( freq , dds_clock_freq )<-13  ' This should be in PASM
                                                   
PUB tune( freq )
  dds_tune :=  0
  waitcnt( 9_000 + cnt )
  dds_sync_time := cnt + 800_000  ' There is room for improvement here
  dds_tune :=  ratio( freq , dds_clock_freq )<-13  ' This should be in PASM

PUB get_tune_addr : a
  a := @dds_tune

PUB get_clock_freq : f
  f := dds_clock_freq
  
  
DAT
      'assembly code starts here'
      org
srccog
  '256 sampled 8-bit sine table. Replace with any sampled waveform you like
  'as long as the data table is of the same dimension and depth. Only longs are
  'used to make the DDS loop as short as possible in terms of clock cycles.
  
  Sine          long $80,$83,$86,$89,$8C,$8F,$92,$95,$98,$9C,$9F,$A2,$A5,$A8,$AB,$AE
                long $B0,$B3,$B6,$B9,$BC,$BF,$C1,$C4,$C7,$C9,$CC,$CE,$D1,$D3,$D5,$D8
                long $DA,$DC,$DE,$E0,$E2,$E4,$E6,$E8,$EA,$EC,$ED,$EF,$F0,$F2,$F3,$F5
                long $F6,$F7,$F8,$F9,$FA,$FB,$FC,$FC,$FD,$FE,$FE,$FF,$FF,$FF,$FF,$FF
                long $FF,$FF,$FF,$FF,$FF,$FF,$FE,$FE,$FD,$FC,$FC,$FB,$FA,$F9,$F8,$F7
                long $F6,$F5,$F3,$F2,$F0,$EF,$ED,$EC,$EA,$E8,$E6,$E4,$E2,$E0,$DE,$DC
                long $DA,$D8,$D5,$D3,$D1,$CE,$CC,$C9,$C7,$C4,$C1,$BF,$BC,$B9,$B6,$B3
                long $B0,$AE,$AB,$A8,$A5,$A2,$9F,$9C,$98,$95,$92,$8F,$8C,$89,$86,$83
                long $80,$7C,$79,$76,$73,$70,$6D,$6A,$67,$63,$60,$5D,$5A,$57,$54,$51
                long $4F,$4C,$49,$46,$43,$40,$3E,$3B,$38,$36,$33,$31,$2E,$2C,$2A,$27
                long $25,$23,$21,$1F,$1D,$1B,$19,$17,$15,$13,$12,$10,$0F,$0D,$0C,$0A
                long $09,$08,$07,$06,$05,$04,$03,$03,$02,$01,$01,$00,$00,$00,$00,$00
                long $00,$00,$00,$00,$00,$00,$01,$01,$02,$03,$03,$04,$05,$06,$07,$08
                long $09,$0A,$0C,$0D,$0F,$10,$12,$13,$15,$17,$19,$1B,$1D,$1F,$21,$23
                long $25,$27,$2A,$2C,$2E,$31,$33,$36,$38,$3B,$3E,$40,$43,$46,$49,$4C
                long $4F,$51,$54,$57,$5A,$5D,$60,$63,$67,$6A,$6D,$70,$73,$76,$79,$7C
                
                
                mov dira, txp_pin
                

                mov     loopi,#256   
:extractread    mov     slice,0-0
                movd    :extractwrite, :extractread                
                add     :extractread,#1
                shr     slice,ddsp_shift
                and     slice,#1
:extractwrite   mov     0-0,slice
                djnz    loopi,#:extractread
                

                
waitforfreq     rdlong  M,ddsp_tune  wz    
                'nop  
        if_z    jmp     #waitforfreq
                ror     M,#5               ' divide by 32 for single step

                
                
                mov     wptr,#0
                mov     loopi,#256   
:shiftlongloop  movd    :shiftwrite, wptr 
                mov     rptr,wptr
                mov     loopj,#32
                mov     temp,#0    wc ' clear carry for accumulator 
:shiftbitloop   andn    rptr,#$100
                movs    :shiftread,rptr     
                nop
:shiftread      mov     slice,0-0
                and     slice,#1
                shl     slice,#31
                shr     temp,#1
                or      temp,slice
                addx    rptr,M wc
                djnz    loopj,#:shiftbitloop
:shiftwrite     mov     0-0,temp

                add     wptr,#1
                djnz    loopi,#:shiftlongloop
  

                

entry           rdlong  wait, #0                ' clkfreq
                shr     wait, #10               ' ~1ms                  (%%)
                
                rdlong  loopi, ddsp_time        ' initial sync target
                mov     ctra,#0 
                mov     phsa,#0                 ' Counter phase must be zero

                cogid   cref                
                shl     cref,#1                 ' ensure cogs access the hub in order
                add     cref,loopi   
                
                waitcnt cref, wait              ' sync cogs
                                                ' 
                rdlong  M,ddsp_tune             ' sync with hub
                mov     wait, cnt 
                add     wait,ddsp_phd
                waitcnt wait,#0
                             
                movi    ctra, #%0_00001_111     ' PLL, VCO/1
                mov     frqa, frqaval           ' 8MHz * 16 / 1 = 128MHz
                mov     vscl, #1                ' reload as fast as possible
                
                movd    vcfg, ddsp_vgrp         ' pin group
                movs    vcfg, #%0_11111111      ' pins
                movi    vcfg, #%0_01_0_00_000   ' VGA, 2 color

                waitcnt cref, #0                ' PLL settled           (%%)
                                                ' frame counter flushed
                                                ' 
                rdlong  M,ddsp_tune             ' sync with hub, introduces an
                                                ' offset of 2*cogid sysclocks
                                                
                ror     vcfg, #1                ' freeze video h/w
                mov     vscl, vscl_long         ' transfer user value

                mov     wait, cnt 
                add     wait,ddsp_phd
                waitcnt wait,#0
                
                rol     vcfg, #1                ' unfreeze
                nop                             ' get some distance

vidloop       
' We load the video generator every 20 sysclocks (32 vidclocks).
' The hub is accessible every 16 sysclocks.
' The least common multiple is 80. 
' So, vidloop must contain a multiple of 4 waitvids+whops 
:whop1          waitvid clr_send,one
                rdlong  M,ddsp_tune   wz       
:whop2          waitvid clr_send,zero 
                'mov     phsa,phsaval       ' Test Loop
                'waitvid clr_send,zero      ' Test Loop
                'waitvid clr_send,zero      ' Test Loop
     'if_nz      jmp     #vidloop           ' Test Loop
                'ror     vcfg, #1           ' Test Stop Method
                'mov     ctra,#0            ' Test Stop Method
                'mov     frqa,#0            ' Test Stop Method
                'jmp     #waitforfreq       ' Test Stop Method
                mov     phsa,phsaval            ' Reset NCO phase 
                addx    accu,M  wc              ' Accum 1
                andn    accu,#%1_00000000       ' Mask  1
:whop3          cmp     clr_send,0-0    'WHOP
                movs    :whop1,accu             ' Store 1
                addx    accu,M  wc              ' Accum 2
                andn    accu,#%1_00000000       ' Mask  2
                movs    :whop2,accu             ' Store 2
:whop4          cmp     clr_send,0-0    'WHOP 
                addx    accu,M  wc              ' Accum 3
                andn    accu,#%1_00000000       ' Mask  3
                movs    :whop3,accu             ' Store 3
                addx    accu,M  wc              ' Accum 4
:whop5          cmp     clr_send,0-0    'WHOP 
                andn    accu,#%1_00000000       ' Mask  4
                movs    :whop4,accu             ' Store 4
                addx    accu,M  wc              ' Accum 5
                andn    accu,#%1_00000000       ' Mask  5
:whop6          cmp     clr_send,0-0    'WHOP 
                movs    :whop5,accu             ' Store 5
                addx    accu,M  wc              ' Accum 6
                andn    accu,#%1_00000000       ' Mask  6
                movs    :whop6,accu             ' Store 6
:whop7          cmp     clr_send,0-0    'WHOP 
                addx    accu,M  wc              ' Accum 7
                andn    accu,#%1_00000000       ' Mask  7
                movs    :whop7,accu             ' Store 7
                addx    accu,M  wc              ' Accum 8
:whop8          cmp     clr_send,0-0    'WHOP 
                andn    accu,#%1_00000000       ' Mask  8
                movs    :whop8,accu             ' Store 8
        if_nz   jmp     #vidloop
        ' If we get here, we have received a signal to retune the tables 
                ror     vcfg, #1                ' freeze video h/w      
                mov     ctra,#0 'off
                mov     frqa,#0
                jmp     #waitforfreq   



' Parameters that are set up by Spin code prior to cognew()
ddsp_tune       long      0
ddsp_time       long      0
ddsp_vgrp       long      0
ddsp_shift      long      6
ddsp_phd        long      16
txp_pin         long      0 


' Variables 

accu      long 0 
wptr      long 0
rptr      long 0
temp      long 0
slice     long 0
loopi     long 0
loopj     long 0 
wait      long 0 
cref      long 0 
M         long 1 

'  Constants
frqaval    long $1999_999a  
phsaval    long ($1999_999a)*9        ' phsaval magic number is the factor at the end
                                      

'clr_send long $ffaa5500 '(255)<<8    ' for 4 color mode
clr_send   long $ffff_ff00
vscl_long  long 1<<12 + 32


one       long $ffff_ffff
zero      long 0



' res must go after long

fit

